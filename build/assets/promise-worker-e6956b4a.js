function p(s){if(typeof WorkerGlobalScope>"u"){console.error("Expose not called in worker thread");return}const i=function(n,e){postMessage({id:n.id,type:"success",payload:e})},c=function(n,e){postMessage({id:n.id,type:"error",payload:e})},a=function(){return Object.keys(s).filter(e=>typeof s[e]=="function")},l=function(n){const e=s[n.action],o=n.payload,t=e(...o);return t instanceof Promise?t:Promise.resolve(t)};onmessage=async function(n){const e=n.data;try{let o;e.action==="getFunctionality"?o=a():o=await l(e),i(e,o)}catch(o){c(e,o)}}}async function d(s){let i=0;const c=[],a=function(e){const o={...e,id:i++},t=new Promise((r,u)=>{c.push({request:o,resolve:r,reject:u})});return s.postMessage(o),t};s.onmessage=function(e){const o=e.data,t=c.findIndex(r=>r.request.id==o.id);if(t<0){console.error("Worker responded to nonexistent job"),console.warn("Worker's response:",o);return}else{const r=c.splice(t,1)[0];o.type=="success"?r.resolve(o.payload):r.reject(o.payload)}},s.onerror=function(e){console.error("Uncaught error in worker:",e),c.splice(0,c.length).forEach(t=>t.reject(e))};const l=await a({action:"getFunctionality",payload:[]}),n={};return l.forEach(e=>n[e]=(...o)=>a({action:e,payload:o})),n.terminate=()=>s.terminate(),n}export{p as e,d as w};
